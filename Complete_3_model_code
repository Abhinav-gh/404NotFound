{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "PFop7A1Vfvjm"
      },
      "source": [
        "# 1. Install Gradio and Required Libraries\n",
        "### Start by installing Gradio if it's not already installed."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ewtMbahKcF3w",
        "outputId": "543b54ae-f92b-4caa-8c39-a8b3bdbb824d",
        "collapsed": true
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Requirement already satisfied: gradio in /usr/local/lib/python3.10/dist-packages (5.1.0)\n",
            "Requirement already satisfied: aiofiles<24.0,>=22.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (23.2.1)\n",
            "Requirement already satisfied: anyio<5.0,>=3.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (3.7.1)\n",
            "Requirement already satisfied: fastapi<1.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (0.115.2)\n",
            "Requirement already satisfied: ffmpy in /usr/local/lib/python3.10/dist-packages (from gradio) (0.4.0)\n",
            "Requirement already satisfied: gradio-client==1.4.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (1.4.0)\n",
            "Requirement already satisfied: httpx>=0.24.1 in /usr/local/lib/python3.10/dist-packages (from gradio) (0.27.2)\n",
            "Requirement already satisfied: huggingface-hub>=0.25.1 in /usr/local/lib/python3.10/dist-packages (from gradio) (0.26.0)\n",
            "Requirement already satisfied: jinja2<4.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (3.1.4)\n",
            "Requirement already satisfied: markupsafe~=2.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (2.1.5)\n",
            "Requirement already satisfied: numpy<3.0,>=1.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (1.26.4)\n",
            "Requirement already satisfied: orjson~=3.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (3.10.7)\n",
            "Requirement already satisfied: packaging in /usr/local/lib/python3.10/dist-packages (from gradio) (24.1)\n",
            "Requirement already satisfied: pandas<3.0,>=1.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (2.2.2)\n",
            "Requirement already satisfied: pillow<11.0,>=8.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (10.4.0)\n",
            "Requirement already satisfied: pydantic>=2.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (2.9.2)\n",
            "Requirement already satisfied: pydub in /usr/local/lib/python3.10/dist-packages (from gradio) (0.25.1)\n",
            "Requirement already satisfied: python-multipart>=0.0.9 in /usr/local/lib/python3.10/dist-packages (from gradio) (0.0.12)\n",
            "Requirement already satisfied: pyyaml<7.0,>=5.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (6.0.2)\n",
            "Requirement already satisfied: ruff>=0.2.2 in /usr/local/lib/python3.10/dist-packages (from gradio) (0.7.0)\n",
            "Requirement already satisfied: semantic-version~=2.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (2.10.0)\n",
            "Requirement already satisfied: tomlkit==0.12.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (0.12.0)\n",
            "Requirement already satisfied: typer<1.0,>=0.12 in /usr/local/lib/python3.10/dist-packages (from gradio) (0.12.5)\n",
            "Requirement already satisfied: typing-extensions~=4.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (4.12.2)\n",
            "Requirement already satisfied: uvicorn>=0.14.0 in /usr/local/lib/python3.10/dist-packages (from gradio) (0.32.0)\n",
            "Requirement already satisfied: fsspec in /usr/local/lib/python3.10/dist-packages (from gradio-client==1.4.0->gradio) (2024.6.1)\n",
            "Requirement already satisfied: websockets<13.0,>=10.0 in /usr/local/lib/python3.10/dist-packages (from gradio-client==1.4.0->gradio) (12.0)\n",
            "Requirement already satisfied: idna>=2.8 in /usr/local/lib/python3.10/dist-packages (from anyio<5.0,>=3.0->gradio) (3.10)\n",
            "Requirement already satisfied: sniffio>=1.1 in /usr/local/lib/python3.10/dist-packages (from anyio<5.0,>=3.0->gradio) (1.3.1)\n",
            "Requirement already satisfied: exceptiongroup in /usr/local/lib/python3.10/dist-packages (from anyio<5.0,>=3.0->gradio) (1.2.2)\n",
            "Requirement already satisfied: starlette<0.41.0,>=0.37.2 in /usr/local/lib/python3.10/dist-packages (from fastapi<1.0->gradio) (0.40.0)\n",
            "Requirement already satisfied: certifi in /usr/local/lib/python3.10/dist-packages (from httpx>=0.24.1->gradio) (2024.8.30)\n",
            "Requirement already satisfied: httpcore==1.* in /usr/local/lib/python3.10/dist-packages (from httpx>=0.24.1->gradio) (1.0.6)\n",
            "Requirement already satisfied: h11<0.15,>=0.13 in /usr/local/lib/python3.10/dist-packages (from httpcore==1.*->httpx>=0.24.1->gradio) (0.14.0)\n",
            "Requirement already satisfied: filelock in /usr/local/lib/python3.10/dist-packages (from huggingface-hub>=0.25.1->gradio) (3.16.1)\n",
            "Requirement already satisfied: requests in /usr/local/lib/python3.10/dist-packages (from huggingface-hub>=0.25.1->gradio) (2.32.3)\n",
            "Requirement already satisfied: tqdm>=4.42.1 in /usr/local/lib/python3.10/dist-packages (from huggingface-hub>=0.25.1->gradio) (4.66.5)\n",
            "Requirement already satisfied: python-dateutil>=2.8.2 in /usr/local/lib/python3.10/dist-packages (from pandas<3.0,>=1.0->gradio) (2.8.2)\n",
            "Requirement already satisfied: pytz>=2020.1 in /usr/local/lib/python3.10/dist-packages (from pandas<3.0,>=1.0->gradio) (2024.2)\n",
            "Requirement already satisfied: tzdata>=2022.7 in /usr/local/lib/python3.10/dist-packages (from pandas<3.0,>=1.0->gradio) (2024.2)\n",
            "Requirement already satisfied: annotated-types>=0.6.0 in /usr/local/lib/python3.10/dist-packages (from pydantic>=2.0->gradio) (0.7.0)\n",
            "Requirement already satisfied: pydantic-core==2.23.4 in /usr/local/lib/python3.10/dist-packages (from pydantic>=2.0->gradio) (2.23.4)\n",
            "Requirement already satisfied: click>=8.0.0 in /usr/local/lib/python3.10/dist-packages (from typer<1.0,>=0.12->gradio) (8.1.7)\n",
            "Requirement already satisfied: shellingham>=1.3.0 in /usr/local/lib/python3.10/dist-packages (from typer<1.0,>=0.12->gradio) (1.5.4)\n",
            "Requirement already satisfied: rich>=10.11.0 in /usr/local/lib/python3.10/dist-packages (from typer<1.0,>=0.12->gradio) (13.9.2)\n",
            "Requirement already satisfied: six>=1.5 in /usr/local/lib/python3.10/dist-packages (from python-dateutil>=2.8.2->pandas<3.0,>=1.0->gradio) (1.16.0)\n",
            "Requirement already satisfied: markdown-it-py>=2.2.0 in /usr/local/lib/python3.10/dist-packages (from rich>=10.11.0->typer<1.0,>=0.12->gradio) (3.0.0)\n",
            "Requirement already satisfied: pygments<3.0.0,>=2.13.0 in /usr/local/lib/python3.10/dist-packages (from rich>=10.11.0->typer<1.0,>=0.12->gradio) (2.18.0)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests->huggingface-hub>=0.25.1->gradio) (3.4.0)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests->huggingface-hub>=0.25.1->gradio) (2.2.3)\n",
            "Requirement already satisfied: mdurl~=0.1 in /usr/local/lib/python3.10/dist-packages (from markdown-it-py>=2.2.0->rich>=10.11.0->typer<1.0,>=0.12->gradio) (0.1.2)\n",
            "Requirement already satisfied: cv in /usr/local/lib/python3.10/dist-packages (1.0.0)\n",
            "Requirement already satisfied: ultralytics in /usr/local/lib/python3.10/dist-packages (8.3.17)\n",
            "Requirement already satisfied: numpy>=1.23.0 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (1.26.4)\n",
            "Requirement already satisfied: matplotlib>=3.3.0 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (3.7.1)\n",
            "Requirement already satisfied: opencv-python>=4.6.0 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (4.10.0.84)\n",
            "Requirement already satisfied: pillow>=7.1.2 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (10.4.0)\n",
            "Requirement already satisfied: pyyaml>=5.3.1 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (6.0.2)\n",
            "Requirement already satisfied: requests>=2.23.0 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (2.32.3)\n",
            "Requirement already satisfied: scipy>=1.4.1 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (1.13.1)\n",
            "Requirement already satisfied: torch>=1.8.0 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (2.4.1+cu121)\n",
            "Requirement already satisfied: torchvision>=0.9.0 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (0.19.1+cu121)\n",
            "Requirement already satisfied: tqdm>=4.64.0 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (4.66.5)\n",
            "Requirement already satisfied: psutil in /usr/local/lib/python3.10/dist-packages (from ultralytics) (5.9.5)\n",
            "Requirement already satisfied: py-cpuinfo in /usr/local/lib/python3.10/dist-packages (from ultralytics) (9.0.0)\n",
            "Requirement already satisfied: pandas>=1.1.4 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (2.2.2)\n",
            "Requirement already satisfied: seaborn>=0.11.0 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (0.13.2)\n",
            "Requirement already satisfied: ultralytics-thop>=2.0.0 in /usr/local/lib/python3.10/dist-packages (from ultralytics) (2.0.9)\n",
            "Requirement already satisfied: contourpy>=1.0.1 in /usr/local/lib/python3.10/dist-packages (from matplotlib>=3.3.0->ultralytics) (1.3.0)\n",
            "Requirement already satisfied: cycler>=0.10 in /usr/local/lib/python3.10/dist-packages (from matplotlib>=3.3.0->ultralytics) (0.12.1)\n",
            "Requirement already satisfied: fonttools>=4.22.0 in /usr/local/lib/python3.10/dist-packages (from matplotlib>=3.3.0->ultralytics) (4.54.1)\n",
            "Requirement already satisfied: kiwisolver>=1.0.1 in /usr/local/lib/python3.10/dist-packages (from matplotlib>=3.3.0->ultralytics) (1.4.7)\n",
            "Requirement already satisfied: packaging>=20.0 in /usr/local/lib/python3.10/dist-packages (from matplotlib>=3.3.0->ultralytics) (24.1)\n",
            "Requirement already satisfied: pyparsing>=2.3.1 in /usr/local/lib/python3.10/dist-packages (from matplotlib>=3.3.0->ultralytics) (3.2.0)\n",
            "Requirement already satisfied: python-dateutil>=2.7 in /usr/local/lib/python3.10/dist-packages (from matplotlib>=3.3.0->ultralytics) (2.8.2)\n",
            "Requirement already satisfied: pytz>=2020.1 in /usr/local/lib/python3.10/dist-packages (from pandas>=1.1.4->ultralytics) (2024.2)\n",
            "Requirement already satisfied: tzdata>=2022.7 in /usr/local/lib/python3.10/dist-packages (from pandas>=1.1.4->ultralytics) (2024.2)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->ultralytics) (3.4.0)\n",
            "Requirement already satisfied: idna<4,>=2.5 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->ultralytics) (3.10)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->ultralytics) (2.2.3)\n",
            "Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests>=2.23.0->ultralytics) (2024.8.30)\n",
            "Requirement already satisfied: filelock in /usr/local/lib/python3.10/dist-packages (from torch>=1.8.0->ultralytics) (3.16.1)\n",
            "Requirement already satisfied: typing-extensions>=4.8.0 in /usr/local/lib/python3.10/dist-packages (from torch>=1.8.0->ultralytics) (4.12.2)\n",
            "Requirement already satisfied: sympy in /usr/local/lib/python3.10/dist-packages (from torch>=1.8.0->ultralytics) (1.13.3)\n",
            "Requirement already satisfied: networkx in /usr/local/lib/python3.10/dist-packages (from torch>=1.8.0->ultralytics) (3.4.1)\n",
            "Requirement already satisfied: jinja2 in /usr/local/lib/python3.10/dist-packages (from torch>=1.8.0->ultralytics) (3.1.4)\n",
            "Requirement already satisfied: fsspec in /usr/local/lib/python3.10/dist-packages (from torch>=1.8.0->ultralytics) (2024.6.1)\n",
            "Requirement already satisfied: six>=1.5 in /usr/local/lib/python3.10/dist-packages (from python-dateutil>=2.7->matplotlib>=3.3.0->ultralytics) (1.16.0)\n",
            "Requirement already satisfied: MarkupSafe>=2.0 in /usr/local/lib/python3.10/dist-packages (from jinja2->torch>=1.8.0->ultralytics) (2.1.5)\n",
            "Requirement already satisfied: mpmath<1.4,>=1.1.0 in /usr/local/lib/python3.10/dist-packages (from sympy->torch>=1.8.0->ultralytics) (1.3.0)\n",
            "Requirement already satisfied: google-generativeai in /usr/local/lib/python3.10/dist-packages (0.8.3)\n",
            "Requirement already satisfied: google-ai-generativelanguage==0.6.10 in /usr/local/lib/python3.10/dist-packages (from google-generativeai) (0.6.10)\n",
            "Requirement already satisfied: google-api-core in /usr/local/lib/python3.10/dist-packages (from google-generativeai) (2.19.2)\n",
            "Requirement already satisfied: google-api-python-client in /usr/local/lib/python3.10/dist-packages (from google-generativeai) (2.137.0)\n",
            "Requirement already satisfied: google-auth>=2.15.0 in /usr/local/lib/python3.10/dist-packages (from google-generativeai) (2.27.0)\n",
            "Requirement already satisfied: protobuf in /usr/local/lib/python3.10/dist-packages (from google-generativeai) (3.20.3)\n",
            "Requirement already satisfied: pydantic in /usr/local/lib/python3.10/dist-packages (from google-generativeai) (2.9.2)\n",
            "Requirement already satisfied: tqdm in /usr/local/lib/python3.10/dist-packages (from google-generativeai) (4.66.5)\n",
            "Requirement already satisfied: typing-extensions in /usr/local/lib/python3.10/dist-packages (from google-generativeai) (4.12.2)\n",
            "Requirement already satisfied: proto-plus<2.0.0dev,>=1.22.3 in /usr/local/lib/python3.10/dist-packages (from google-ai-generativelanguage==0.6.10->google-generativeai) (1.24.0)\n",
            "Requirement already satisfied: googleapis-common-protos<2.0.dev0,>=1.56.2 in /usr/local/lib/python3.10/dist-packages (from google-api-core->google-generativeai) (1.65.0)\n",
            "Requirement already satisfied: requests<3.0.0.dev0,>=2.18.0 in /usr/local/lib/python3.10/dist-packages (from google-api-core->google-generativeai) (2.32.3)\n",
            "Requirement already satisfied: cachetools<6.0,>=2.0.0 in /usr/local/lib/python3.10/dist-packages (from google-auth>=2.15.0->google-generativeai) (5.5.0)\n",
            "Requirement already satisfied: pyasn1-modules>=0.2.1 in /usr/local/lib/python3.10/dist-packages (from google-auth>=2.15.0->google-generativeai) (0.4.1)\n",
            "Requirement already satisfied: rsa<5,>=3.1.4 in /usr/local/lib/python3.10/dist-packages (from google-auth>=2.15.0->google-generativeai) (4.9)\n",
            "Requirement already satisfied: httplib2<1.dev0,>=0.19.0 in /usr/local/lib/python3.10/dist-packages (from google-api-python-client->google-generativeai) (0.22.0)\n",
            "Requirement already satisfied: google-auth-httplib2<1.0.0,>=0.2.0 in /usr/local/lib/python3.10/dist-packages (from google-api-python-client->google-generativeai) (0.2.0)\n",
            "Requirement already satisfied: uritemplate<5,>=3.0.1 in /usr/local/lib/python3.10/dist-packages (from google-api-python-client->google-generativeai) (4.1.1)\n",
            "Requirement already satisfied: annotated-types>=0.6.0 in /usr/local/lib/python3.10/dist-packages (from pydantic->google-generativeai) (0.7.0)\n",
            "Requirement already satisfied: pydantic-core==2.23.4 in /usr/local/lib/python3.10/dist-packages (from pydantic->google-generativeai) (2.23.4)\n",
            "Requirement already satisfied: grpcio<2.0dev,>=1.33.2 in /usr/local/lib/python3.10/dist-packages (from google-api-core[grpc]!=2.0.*,!=2.1.*,!=2.10.*,!=2.2.*,!=2.3.*,!=2.4.*,!=2.5.*,!=2.6.*,!=2.7.*,!=2.8.*,!=2.9.*,<3.0.0dev,>=1.34.1->google-ai-generativelanguage==0.6.10->google-generativeai) (1.64.1)\n",
            "Requirement already satisfied: grpcio-status<2.0.dev0,>=1.33.2 in /usr/local/lib/python3.10/dist-packages (from google-api-core[grpc]!=2.0.*,!=2.1.*,!=2.10.*,!=2.2.*,!=2.3.*,!=2.4.*,!=2.5.*,!=2.6.*,!=2.7.*,!=2.8.*,!=2.9.*,<3.0.0dev,>=1.34.1->google-ai-generativelanguage==0.6.10->google-generativeai) (1.48.2)\n",
            "Requirement already satisfied: pyparsing!=3.0.0,!=3.0.1,!=3.0.2,!=3.0.3,<4,>=2.4.2 in /usr/local/lib/python3.10/dist-packages (from httplib2<1.dev0,>=0.19.0->google-api-python-client->google-generativeai) (3.2.0)\n",
            "Requirement already satisfied: pyasn1<0.7.0,>=0.4.6 in /usr/local/lib/python3.10/dist-packages (from pyasn1-modules>=0.2.1->google-auth>=2.15.0->google-generativeai) (0.6.1)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests<3.0.0.dev0,>=2.18.0->google-api-core->google-generativeai) (3.4.0)\n",
            "Requirement already satisfied: idna<4,>=2.5 in /usr/local/lib/python3.10/dist-packages (from requests<3.0.0.dev0,>=2.18.0->google-api-core->google-generativeai) (3.10)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests<3.0.0.dev0,>=2.18.0->google-api-core->google-generativeai) (2.2.3)\n",
            "Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests<3.0.0.dev0,>=2.18.0->google-api-core->google-generativeai) (2024.8.30)\n",
            "Requirement already satisfied: paddleocr in /usr/local/lib/python3.10/dist-packages (2.9.0)\n",
            "Requirement already satisfied: shapely in /usr/local/lib/python3.10/dist-packages (from paddleocr) (2.0.6)\n",
            "Requirement already satisfied: scikit-image in /usr/local/lib/python3.10/dist-packages (from paddleocr) (0.24.0)\n",
            "Requirement already satisfied: imgaug in /usr/local/lib/python3.10/dist-packages (from paddleocr) (0.4.0)\n",
            "Requirement already satisfied: pyclipper in /usr/local/lib/python3.10/dist-packages (from paddleocr) (1.3.0.post6)\n",
            "Requirement already satisfied: lmdb in /usr/local/lib/python3.10/dist-packages (from paddleocr) (1.5.1)\n",
            "Requirement already satisfied: tqdm in /usr/local/lib/python3.10/dist-packages (from paddleocr) (4.66.5)\n",
            "Requirement already satisfied: numpy<2.0 in /usr/local/lib/python3.10/dist-packages (from paddleocr) (1.26.4)\n",
            "Requirement already satisfied: rapidfuzz in /usr/local/lib/python3.10/dist-packages (from paddleocr) (3.10.0)\n",
            "Requirement already satisfied: opencv-python in /usr/local/lib/python3.10/dist-packages (from paddleocr) (4.10.0.84)\n",
            "Requirement already satisfied: opencv-contrib-python in /usr/local/lib/python3.10/dist-packages (from paddleocr) (4.10.0.84)\n",
            "Requirement already satisfied: cython in /usr/local/lib/python3.10/dist-packages (from paddleocr) (3.0.11)\n",
            "Requirement already satisfied: Pillow in /usr/local/lib/python3.10/dist-packages (from paddleocr) (10.4.0)\n",
            "Requirement already satisfied: pyyaml in /usr/local/lib/python3.10/dist-packages (from paddleocr) (6.0.2)\n",
            "Requirement already satisfied: python-docx in /usr/local/lib/python3.10/dist-packages (from paddleocr) (1.1.2)\n",
            "Requirement already satisfied: beautifulsoup4 in /usr/local/lib/python3.10/dist-packages (from paddleocr) (4.12.3)\n",
            "Requirement already satisfied: fonttools>=4.24.0 in /usr/local/lib/python3.10/dist-packages (from paddleocr) (4.54.1)\n",
            "Requirement already satisfied: fire>=0.3.0 in /usr/local/lib/python3.10/dist-packages (from paddleocr) (0.7.0)\n",
            "Requirement already satisfied: requests in /usr/local/lib/python3.10/dist-packages (from paddleocr) (2.32.3)\n",
            "Requirement already satisfied: termcolor in /usr/local/lib/python3.10/dist-packages (from fire>=0.3.0->paddleocr) (2.5.0)\n",
            "Requirement already satisfied: soupsieve>1.2 in /usr/local/lib/python3.10/dist-packages (from beautifulsoup4->paddleocr) (2.6)\n",
            "Requirement already satisfied: six in /usr/local/lib/python3.10/dist-packages (from imgaug->paddleocr) (1.16.0)\n",
            "Requirement already satisfied: scipy in /usr/local/lib/python3.10/dist-packages (from imgaug->paddleocr) (1.13.1)\n",
            "Requirement already satisfied: matplotlib in /usr/local/lib/python3.10/dist-packages (from imgaug->paddleocr) (3.7.1)\n",
            "Requirement already satisfied: imageio in /usr/local/lib/python3.10/dist-packages (from imgaug->paddleocr) (2.35.1)\n",
            "Requirement already satisfied: networkx>=2.8 in /usr/local/lib/python3.10/dist-packages (from scikit-image->paddleocr) (3.4.1)\n",
            "Requirement already satisfied: tifffile>=2022.8.12 in /usr/local/lib/python3.10/dist-packages (from scikit-image->paddleocr) (2024.9.20)\n",
            "Requirement already satisfied: packaging>=21 in /usr/local/lib/python3.10/dist-packages (from scikit-image->paddleocr) (24.1)\n",
            "Requirement already satisfied: lazy-loader>=0.4 in /usr/local/lib/python3.10/dist-packages (from scikit-image->paddleocr) (0.4)\n",
            "Requirement already satisfied: lxml>=3.1.0 in /usr/local/lib/python3.10/dist-packages (from python-docx->paddleocr) (4.9.4)\n",
            "Requirement already satisfied: typing-extensions>=4.9.0 in /usr/local/lib/python3.10/dist-packages (from python-docx->paddleocr) (4.12.2)\n",
            "Requirement already satisfied: charset-normalizer<4,>=2 in /usr/local/lib/python3.10/dist-packages (from requests->paddleocr) (3.4.0)\n",
            "Requirement already satisfied: idna<4,>=2.5 in /usr/local/lib/python3.10/dist-packages (from requests->paddleocr) (3.10)\n",
            "Requirement already satisfied: urllib3<3,>=1.21.1 in /usr/local/lib/python3.10/dist-packages (from requests->paddleocr) (2.2.3)\n",
            "Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.10/dist-packages (from requests->paddleocr) (2024.8.30)\n",
            "Requirement already satisfied: contourpy>=1.0.1 in /usr/local/lib/python3.10/dist-packages (from matplotlib->imgaug->paddleocr) (1.3.0)\n",
            "Requirement already satisfied: cycler>=0.10 in /usr/local/lib/python3.10/dist-packages (from matplotlib->imgaug->paddleocr) (0.12.1)\n",
            "Requirement already satisfied: kiwisolver>=1.0.1 in /usr/local/lib/python3.10/dist-packages (from matplotlib->imgaug->paddleocr) (1.4.7)\n",
            "Requirement already satisfied: pyparsing>=2.3.1 in /usr/local/lib/python3.10/dist-packages (from matplotlib->imgaug->paddleocr) (3.2.0)\n",
            "Requirement already satisfied: python-dateutil>=2.7 in /usr/local/lib/python3.10/dist-packages (from matplotlib->imgaug->paddleocr) (2.8.2)\n",
            "Requirement already satisfied: paddlepaddle in /usr/local/lib/python3.10/dist-packages (2.6.2)\n",
            "Requirement already satisfied: httpx in /usr/local/lib/python3.10/dist-packages (from paddlepaddle) (0.27.2)\n",
            "Requirement already satisfied: numpy>=1.13 in /usr/local/lib/python3.10/dist-packages (from paddlepaddle) (1.26.4)\n",
            "Requirement already satisfied: Pillow in /usr/local/lib/python3.10/dist-packages (from paddlepaddle) (10.4.0)\n",
            "Requirement already satisfied: decorator in /usr/local/lib/python3.10/dist-packages (from paddlepaddle) (4.4.2)\n",
            "Requirement already satisfied: astor in /usr/local/lib/python3.10/dist-packages (from paddlepaddle) (0.8.1)\n",
            "Requirement already satisfied: opt-einsum==3.3.0 in /usr/local/lib/python3.10/dist-packages (from paddlepaddle) (3.3.0)\n",
            "Requirement already satisfied: protobuf>=3.20.2 in /usr/local/lib/python3.10/dist-packages (from paddlepaddle) (3.20.3)\n",
            "Requirement already satisfied: anyio in /usr/local/lib/python3.10/dist-packages (from httpx->paddlepaddle) (3.7.1)\n",
            "Requirement already satisfied: certifi in /usr/local/lib/python3.10/dist-packages (from httpx->paddlepaddle) (2024.8.30)\n",
            "Requirement already satisfied: httpcore==1.* in /usr/local/lib/python3.10/dist-packages (from httpx->paddlepaddle) (1.0.6)\n",
            "Requirement already satisfied: idna in /usr/local/lib/python3.10/dist-packages (from httpx->paddlepaddle) (3.10)\n",
            "Requirement already satisfied: sniffio in /usr/local/lib/python3.10/dist-packages (from httpx->paddlepaddle) (1.3.1)\n",
            "Requirement already satisfied: h11<0.15,>=0.13 in /usr/local/lib/python3.10/dist-packages (from httpcore==1.*->httpx->paddlepaddle) (0.14.0)\n",
            "Requirement already satisfied: exceptiongroup in /usr/local/lib/python3.10/dist-packages (from anyio->httpx->paddlepaddle) (1.2.2)\n"
          ]
        }
      ],
      "source": [
        "! pip install gradio\n",
        "! pip install cv\n",
        "! pip install ultralytics\n",
        "!pip install google-generativeai\n",
        "!pip install paddleocr\n",
        "!pip install paddlepaddle"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "SRN1sfE1f83w"
      },
      "source": [
        "# 2. Import Libraries\n",
        "### Getting all the necessary Libraries"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "UAv0vzXggDUv"
      },
      "outputs": [],
      "source": [
        "import gradio as gr\n",
        "import random\n",
        "import numpy as np\n",
        "from PIL import Image\n",
        "import cv2\n",
        "import time\n",
        "from ultralytics import YOLO\n",
        "import pandas as pd\n",
        "from google.colab.patches import cv2_imshow\n",
        "from IPython.display import clear_output\n",
        "from collections import defaultdict, deque\n",
        "import matplotlib.pyplot as plt\n",
        "import torch\n",
        "from PIL import Image\n",
        "from torchvision import transforms, models\n",
        "import torch.nn as nn\n",
        "import matplotlib.pyplot as plt\n",
        "import google.generativeai as genai\n",
        "from google.colab import userdata\n",
        "from datetime import datetime\n",
        "from paddleocr import PaddleOCR\n",
        "from google.colab import files"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "VBUU8AruRPZh"
      },
      "source": [
        "# 3. Import Drive\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "vhR2uY9bRTau",
        "outputId": "75662f27-ad52-4de1-8dcb-d045848f47a2"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n"
          ]
        }
      ],
      "source": [
        "from google.colab import drive\n",
        "drive.mount('/content/drive')"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "qiZYtWJSgHK2"
      },
      "source": [
        "# 4. Brand Recognition Backend\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "aOQpUpnWQZs8"
      },
      "source": [
        "### Image uploading for Grocery detection"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "ARthG_EiPujD"
      },
      "outputs": [],
      "source": [
        "def detect_grocery_items(image):\n",
        "    model = YOLO('kitkat_s.pt')\n",
        "    image = np.array(image)[:, :, ::-1]\n",
        "    results = model(image)\n",
        "    annotated_image = results[0].plot()\n",
        "\n",
        "    class_ids = results[0].boxes.cls.cpu().numpy()\n",
        "    confidences = results[0].boxes.conf.cpu().numpy()\n",
        "\n",
        "    threshold = 0.4\n",
        "    class_counts = {}\n",
        "    class_confidences = {}\n",
        "\n",
        "    for i, class_id in enumerate(class_ids):\n",
        "        confidence = confidences[i]\n",
        "        if confidence >= threshold:\n",
        "            class_name = model.names[int(class_id)]\n",
        "\n",
        "            if class_name in class_counts:\n",
        "                class_counts[class_name] += 1\n",
        "            else:\n",
        "                class_counts[class_name] = 1\n",
        "\n",
        "            if class_name in class_confidences:\n",
        "                class_confidences[class_name].append(confidence)\n",
        "            else:\n",
        "                class_confidences[class_name] = [confidence]\n",
        "\n",
        "    if not class_counts:\n",
        "        return image, [], \"The model failed to recognize items or the image may contain untrained objects.\"\n",
        "\n",
        "    summary_table = [[class_name, count, f\"{np.mean(class_confidences[class_name]):.2f}\"]\n",
        "                     for class_name, count in class_counts.items()]\n",
        "\n",
        "    annotated_image_rgb = annotated_image[:, :, ::-1]\n",
        "    return annotated_image_rgb, summary_table, \"Object Recognised Successfully ðŸ¥³ \"\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "EDw4WZqQQhvH"
      },
      "source": [
        "### Detect Grovcery brand from video"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "6RIf4Mr91Woi"
      },
      "outputs": [],
      "source": [
        "def iou(box1, box2):\n",
        "    x1 = max(box1[0], box2[0])\n",
        "    y1 = max(box1[1], box2[1])\n",
        "    x2 = min(box1[2], box2[2])\n",
        "    y2 = min(box1[3], box2[3])\n",
        "\n",
        "    intersection = max(0, x2 - x1) * max(0, y2 - y1)\n",
        "    area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n",
        "    area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n",
        "\n",
        "    iou = intersection / float(area1 + area2 - intersection)\n",
        "    return iou"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "iRc7Or0d1Z0N"
      },
      "outputs": [],
      "source": [
        "def smooth_box(box_history):\n",
        "    if not box_history:\n",
        "        return None\n",
        "    return np.mean(box_history, axis=0)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "Uw6XOmA3gTKH"
      },
      "outputs": [],
      "source": [
        "def process_video(input_path, output_path):\n",
        "    model = YOLO('kitkat_n.pt')\n",
        "    cap = cv2.VideoCapture(input_path)\n",
        "\n",
        "    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n",
        "    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n",
        "    fps = int(cap.get(cv2.CAP_PROP_FPS))\n",
        "\n",
        "    fourcc = cv2.VideoWriter_fourcc(*'mp4v')\n",
        "    out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))\n",
        "\n",
        "    detected_items = {}\n",
        "    frame_count = 0\n",
        "\n",
        "    detections_history = defaultdict(lambda: defaultdict(int))\n",
        "\n",
        "    while cap.isOpened():\n",
        "        ret, frame = cap.read()\n",
        "        if not ret:\n",
        "            break\n",
        "\n",
        "        frame_count += 1\n",
        "\n",
        "        if frame_count % 5 == 0:\n",
        "            results = model(frame)\n",
        "\n",
        "            current_frame_detections = []\n",
        "\n",
        "            for r in results:\n",
        "                boxes = r.boxes\n",
        "                for box in boxes:\n",
        "                    x1, y1, x2, y2 = box.xyxy[0].tolist()\n",
        "                    conf = box.conf.item()\n",
        "                    cls = int(box.cls.item())\n",
        "                    brand = model.names[cls]\n",
        "\n",
        "                    current_frame_detections.append((brand, [x1, y1, x2, y2], conf))\n",
        "\n",
        "            for brand, box, conf in current_frame_detections:\n",
        "                matched = False\n",
        "                for item_id, item_info in detected_items.items():\n",
        "                    if iou(box, item_info['smoothed_box']) > 0.5:\n",
        "                        item_info['frames_detected'] += 1\n",
        "                        item_info['total_conf'] += conf\n",
        "                        item_info['box_history'].append(box)\n",
        "                        if len(item_info['box_history']) > 10:\n",
        "                            item_info['box_history'].popleft()\n",
        "                        item_info['smoothed_box'] = smooth_box(item_info['box_history'])\n",
        "                        item_info['last_seen'] = frame_count\n",
        "                        matched = True\n",
        "                        break\n",
        "\n",
        "                if not matched:\n",
        "                    item_id = len(detected_items)\n",
        "                    detected_items[item_id] = {\n",
        "                        'brand': brand,\n",
        "                        'box_history': deque([box], maxlen=10),\n",
        "                        'smoothed_box': box,\n",
        "                        'frames_detected': 1,\n",
        "                        'total_conf': conf,\n",
        "                        'last_seen': frame_count\n",
        "                    }\n",
        "\n",
        "                detections_history[brand][frame_count] += 1\n",
        "\n",
        "\n",
        "        for item_id, item_info in list(detected_items.items()):\n",
        "            if frame_count - item_info['last_seen'] > fps * 2:  # 2 seconds\n",
        "                del detected_items[item_id]\n",
        "                continue\n",
        "\n",
        "            if item_info['smoothed_box'] is not None:\n",
        "                alpha = 0.3\n",
        "                current_box = item_info['smoothed_box']\n",
        "                target_box = item_info['box_history'][-1] if item_info['box_history'] else current_box\n",
        "                interpolated_box = [\n",
        "                    current_box[i] * (1 - alpha) + target_box[i] * alpha\n",
        "                    for i in range(4)\n",
        "                ]\n",
        "                item_info['smoothed_box'] = interpolated_box\n",
        "\n",
        "                x1, y1, x2, y2 = map(int, interpolated_box)\n",
        "                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)\n",
        "                cv2.putText(frame, f\"{item_info['brand']}\",\n",
        "                            (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)\n",
        "\n",
        "        out.write(frame)\n",
        "\n",
        "    cap.release()\n",
        "    out.release()\n",
        "\n",
        "    total_frames = frame_count\n",
        "    confirmed_items = {}\n",
        "    for brand, frame_counts in detections_history.items():\n",
        "        detection_frames = len(frame_counts)\n",
        "        if detection_frames > total_frames * 0.1:\n",
        "            avg_count = sum(frame_counts.values()) / detection_frames\n",
        "            confirmed_items[brand] = round(avg_count)\n",
        "\n",
        "    return confirmed_items"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "Lc2w5YVKnTjC"
      },
      "outputs": [],
      "source": [
        "def annotate_video(input_video):\n",
        "    output_path = 'annotated_output.mp4'\n",
        "    confirmed_items = process_video(input_video, output_path)\n",
        "\n",
        "    item_list = [(brand, quantity) for brand, quantity in confirmed_items.items()]\n",
        "\n",
        "    status_message = \"Video processed successfully!\"\n",
        "\n",
        "    return output_path, item_list, status_message"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "ix5AXFDbQ32Y"
      },
      "source": [
        "# 5. OCR Backend\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "6Oa81GnqbSFu"
      },
      "source": [
        "### The PaddleOCR + Gemini combined type model.\n",
        "\n",
        "Run these 3 cells before trying out any model"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "6NDjFDz3bVov"
      },
      "outputs": [],
      "source": [
        "# Function to draw bounding boxes and show text\n",
        "def draw_bounding_boxes(image_path):\n",
        "    # Read the image\n",
        "    img = Image.open(image_path)\n",
        "    result = ocr.ocr(image_path, cls=True)  # Get the OCR result\n",
        "\n",
        "    # Create a figure to display the image\n",
        "    plt.figure(figsize=(10, 10))\n",
        "    plt.imshow(img)\n",
        "    ax = plt.gca()\n",
        "    all_text_data = []\n",
        "    # Iterate through the results and draw boxes\n",
        "    for idx, line in enumerate(result[0]):\n",
        "        box = line[0]  # Get the bounding box coordinates\n",
        "        text = line[1][0]  # Extracted text\n",
        "        print(f\"[DEBUG] Box {idx + 1}: {text}\")  # Display text with box number\n",
        "        all_text_data.append(f\"{text}\")\n",
        "\n",
        "        # Draw the bounding box\n",
        "        polygon = plt.Polygon(box, fill=None, edgecolor='red', linewidth=2)\n",
        "        ax.add_patch(polygon)\n",
        "        # Add text label in the box\n",
        "        # ax.text(box[0][0], box[0][1] - 5, f\"{idx + 1}: {text}\", color='blue', fontsize=12)\n",
        "\n",
        "    plt.axis('off')  # Hide axes\n",
        "    plt.show()\n",
        "    return all_text_data\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "SAZdPiuIbXBu"
      },
      "outputs": [],
      "source": [
        "# Set your API key securely (store it in Colabâ€™s userdata)\n",
        "GOOGLE_API_KEY= userdata.get('GOOGLE_API_KEY')\n",
        "genai.configure(api_key=GOOGLE_API_KEY)\n",
        "\n",
        "def gemini_context_correction(text):\n",
        "    \"\"\"Use Gemini API to refine noisy OCR results and extract MRP details.\"\"\"\n",
        "    model = genai.GenerativeModel('models/gemini-1.5-flash')\n",
        "\n",
        "    response = model.generate_content(\n",
        "        f\"Identify and extract manufacturing, expiration dates, and MRP from the following text. \"\n",
        "        f\"The dates may be written in dd/mm/yyyy format or as <Month_name> <Year> or <day> <Month_Name> <Year>. \"\n",
        "        f\"The text may contain noise or unclear information. If only one date is provided, assume it is the Expiration Date. \"\n",
        "        f\"Additionally, extract the MRP (e.g., 'MRP: â‚¹99.00', 'Rs. 99/-'). \"\n",
        "        f\"Format the output as:\\n\"\n",
        "        f\"Manufacturing Date: <MFG Date>\\n\"\n",
        "        f\"Expiration Date: <EXP Date>\\n\"\n",
        "        f\"MRP: <MRP Value>\\n\\n\"\n",
        "        f\"Here is the text: {text}\"\n",
        "    )\n",
        "\n",
        "    return response.text\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "jYd6IPcubYpW"
      },
      "outputs": [],
      "source": [
        "def validate_dates_with_gemini(mfg_date, exp_date):\n",
        "    \"\"\"Use Gemini API to validate and correct the manufacturing and expiration dates.\"\"\"\n",
        "    model = genai.GenerativeModel('models/gemini-1.5-flash')\n",
        "    response = model.generate_content = (\n",
        "        f\"Input Manufacturing Date: {mfg_date}, Expiration Date: {exp_date}. \"\n",
        "        f\"If either date is '-1', leave it as is. \"\n",
        "        f\"1. If the expiration date is earlier than the manufacturing date, swap them. \"\n",
        "        f\"2. If both dates are logically incorrect, suggest new valid dates based on typical timeframes. \"\n",
        "        f\"Always respond ONLY in the format:\\n\"\n",
        "        f\"Manufacturing Date: <MFG Date>, Expiration Date: <EXP Date>\"\n",
        "    )\n",
        "\n",
        "    # Check if the response contains valid parts\n",
        "    if response.parts:\n",
        "        # Process the response to extract final dates\n",
        "        final_dates = response.parts[0].text.strip()\n",
        "        return final_dates\n",
        "\n",
        "    # Return a message or a default value if no valid parts are found\n",
        "    return \"Invalid response from Gemini API.\"\n",
        "\n",
        "\n",
        "def extract_and_validate_with_gemini(refined_text):\n",
        "    \"\"\"\n",
        "    Use Gemini API to extract, validate, and correct manufacturing and expiration dates.\n",
        "    \"\"\"\n",
        "    model = genai.GenerativeModel('models/gemini-1.5-flash')\n",
        "\n",
        "    # Correctly call the generate_content method\n",
        "    response = model.generate_content(\n",
        "         f\"The extracted text is:\\n'{refined_text}'\\n\\n\"\n",
        "        f\"1. Extract the 'Manufacturing Date' and 'Expiration Date' from the above text. \"\n",
        "        f\"Ignore unrelated data (e.g., 'MRP: Not Found').\\n\"\n",
        "        f\"2. If a date is missing or invalid, return -1 for that date.\\n\"\n",
        "        f\"3. If the 'Expiration Date' is earlier than the 'Manufacturing Date', swap them.\\n\"\n",
        "        f\"4. Ensure both dates are in 'dd/mm/yyyy' format. If the original dates are not in this format, convert them.\\n\"\n",
        "        f\"Respond ONLY in this exact format:\\n\"\n",
        "        f\"Manufacturing Date: <MFG Date>, Expiration Date: <EXP Date>\"\n",
        "    )\n",
        "    print(\"[DEBUG] Response from validation function\", response)\n",
        "    # Ensure the response object is valid and contains the required parts\n",
        "    if hasattr(response, 'parts') and response.parts:\n",
        "        final_dates = response.parts[0].text.strip()\n",
        "        print(f\"[DEBUG] Gemini Response: {final_dates}\")\n",
        "\n",
        "        # Extract the dates from the response\n",
        "        mfg_date_str, exp_date_str = parse_gemini_response(final_dates)\n",
        "\n",
        "        # Process and swap if necessary\n",
        "        if mfg_date_str != \"-1\" and exp_date_str != \"-1\":\n",
        "            mfg_date = datetime.strptime(mfg_date_str, \"%Y/%m/%d\")\n",
        "            exp_date = datetime.strptime(exp_date_str, \"%Y/%m/%d\")\n",
        "\n",
        "            # Swap if Expiration Date is earlier than Manufacturing Date\n",
        "            if exp_date < mfg_date:\n",
        "                print(\"[DEBUG] Swapping dates.\")\n",
        "                mfg_date, exp_date = exp_date, mfg_date\n",
        "\n",
        "            # Return the formatted swapped dates\n",
        "            return (\n",
        "                f\"Manufacturing Date: {mfg_date.strftime('%Y/%m/%d')}, \"\n",
        "                f\"Expiration Date: {exp_date.strftime('%Y/%m/%d')}\"\n",
        "            )\n",
        "\n",
        "        # If either date is -1, return them as-is\n",
        "        return final_dates\n",
        "\n",
        "    # Handle invalid responses gracefully\n",
        "    print(\"[ERROR] Invalid response from Gemini API.\")\n",
        "    return \"Invalid response from Gemini API.\"\n",
        "\n",
        "def extract_and_validate_with_gemini(refined_text):\n",
        "    \"\"\"\n",
        "    Use Gemini API to extract, validate, correct, and swap dates in 'yyyy/mm/dd' format if necessary.\n",
        "    \"\"\"\n",
        "    model = genai.GenerativeModel('models/gemini-1.5-flash')\n",
        "\n",
        "    # Generate content using Gemini with the refined prompt\n",
        "    response = model.generate_content(\n",
        "        f\"The extracted text is:\\n'{refined_text}'\\n\\n\"\n",
        "        f\"1. Extract the 'Manufacturing Date' and 'Expiration Date' from the above text. \"\n",
        "        f\"Ignore unrelated data (e.g., 'MRP: Not Found').\\n\"\n",
        "        f\"2. If a date is missing or invalid, return -1 for that date.\\n\"\n",
        "        f\"3. If the 'Expiration Date' is earlier than the 'Manufacturing Date', swap them.\\n\"\n",
        "        f\"4. Ensure both dates are in 'dd/mm/yyyy' format. If the original dates are not in this format, convert them.\\n\"\n",
        "        f\"Respond ONLY in this exact format:\\n\"\n",
        "        f\"Manufacturing Date: <MFG Date>, Expiration Date: <EXP Date>\"\n",
        "    )\n",
        "\n",
        "    # Validate the response and extract dates\n",
        "    if hasattr(response, 'parts') and response.parts:\n",
        "        final_dates = response.parts[0].text.strip()\n",
        "        print(f\"[DEBUG] Gemini Response: {final_dates}\")\n",
        "\n",
        "        # Extract the dates from the response\n",
        "        mfg_date_str, exp_date_str = parse_gemini_response(final_dates)\n",
        "\n",
        "        # Process and swap if necessary\n",
        "        if mfg_date_str != \"-1\" and exp_date_str != \"-1\":\n",
        "            mfg_date = datetime.strptime(mfg_date_str, \"%d/%m/%Y\")\n",
        "            exp_date = datetime.strptime(exp_date_str, \"%d/%m/%Y\")\n",
        "\n",
        "            # Swap if Expiration Date is earlier than Manufacturing Date\n",
        "            swapping_statement = \"\"\n",
        "            if exp_date < mfg_date:\n",
        "                print(\"[DEBUG] Swapping dates.\")\n",
        "                mfg_date, exp_date = exp_date, mfg_date\n",
        "                swapping_statement = \"Corrected Dates: \\n\"\n",
        "\n",
        "            # Return the formatted swapped dates\n",
        "            return swapping_statement + (\n",
        "                f\"Manufacturing Date: {mfg_date.strftime('%d/%m/%Y')}, \"\n",
        "                f\"Expiration Date: {exp_date.strftime('%d/%m/%Y')}\"\n",
        "            )\n",
        "\n",
        "        # If either date is -1, return them as-is\n",
        "        return final_dates\n",
        "\n",
        "    # Handle invalid responses gracefully\n",
        "    print(\"[ERROR] Invalid response from Gemini API.\")\n",
        "    return \"Invalid response from Gemini API.\"\n",
        "\n",
        "def parse_gemini_response(response_text):\n",
        "    \"\"\"\n",
        "    Helper function to extract Manufacturing Date and Expiration Date from the response text.\n",
        "    \"\"\"\n",
        "    try:\n",
        "        # Split and extract the dates\n",
        "        parts = response_text.split(\", \")\n",
        "        mfg_date_str = parts[0].split(\": \")[1].strip()\n",
        "        exp_date_str = parts[1].split(\": \")[1].strip()\n",
        "        return mfg_date_str, exp_date_str\n",
        "    except IndexError:\n",
        "        print(\"[ERROR] Failed to parse Gemini response.\")\n",
        "        return \"-1\", \"-1\"\n",
        "\n",
        "def extract_date(refined_text, date_type):\n",
        "    \"\"\"Extract the specified date type from the refined text.\"\"\"\n",
        "    if date_type in refined_text:\n",
        "        try:\n",
        "            # Split the text and find the date for the specified type\n",
        "            parts = refined_text.split(',')\n",
        "            for part in parts:\n",
        "                if date_type in part:\n",
        "                    return part.split(':')[1].strip()  # Return the date value\n",
        "        except IndexError:\n",
        "            return '-1'  # Return -1 if the date is not found\n",
        "    return '-1'  # Return -1 if the date type is not in the text\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7l_pFf52bqx9"
      },
      "source": [
        "### **Model 3**\n",
        "Using Yolov8 x-large model trained till about 75 epochs\n",
        "and\n",
        "Gradio as user interface\n",
        "(in case model fails, we fall back to the approach from model 1)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "_ZAJ79bxbsgV"
      },
      "outputs": [],
      "source": [
        "model = YOLO('/content/drive/MyDrive/OCR_Using_model/Yolo_Dataset/Yolo_Checkpoints/improved-model/improved_Model3/weights/best.pt')"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "TRPUy-YGb7OO"
      },
      "source": [
        "## Driver code to be run after selecting from Model 2 or 3.\n",
        "(Note: not needed for model 1)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "Wuz1SKCEb-T-"
      },
      "outputs": [],
      "source": [
        "def new_draw_bounding_boxes(image):\n",
        "    \"\"\"Draw bounding boxes around detected text in the image and display it.\"\"\"\n",
        "    # If the input is a string (file path), open the image\n",
        "    if isinstance(image, str):\n",
        "        img = Image.open(image)\n",
        "        np_img = np.array(img)  # Convert to NumPy array\n",
        "        ocr_result = ocr.ocr(np_img, cls=True)  # Perform OCR on the array\n",
        "    elif isinstance(image, Image.Image):\n",
        "        np_img = np.array(image)  # Convert PIL Image to NumPy array\n",
        "        ocr_result = ocr.ocr(np_img, cls=True)  # Perform OCR on the array\n",
        "    else:\n",
        "        raise ValueError(\"Input must be a file path or a PIL Image object.\")\n",
        "\n",
        "    # Create a figure to display the image\n",
        "    plt.figure(figsize=(10, 10))\n",
        "    plt.imshow(image)\n",
        "    ax = plt.gca()\n",
        "    all_text_data = []\n",
        "\n",
        "    # Iterate through the OCR results and draw boxes\n",
        "    for idx, line in enumerate(ocr_result[0]):\n",
        "        box = line[0]  # Get the bounding box coordinates\n",
        "        text = line[1][0]  # Extracted text\n",
        "        print(f\"[DEBUG] Box {idx + 1}: {text}\")  # Debug print\n",
        "        all_text_data.append(text)\n",
        "\n",
        "        # Draw the bounding box\n",
        "        polygon = plt.Polygon(box, fill=None, edgecolor='red', linewidth=2)\n",
        "        ax.add_patch(polygon)\n",
        "\n",
        "        # Add text label with a small offset for visibility\n",
        "        x, y = box[0][0], box[0][1]\n",
        "        ax.text(x, y - 5, f\"{idx + 1}: {text}\", color='blue', fontsize=12, ha='left')\n",
        "\n",
        "    plt.axis('off')  # Hide axes\n",
        "    plt.title(\"Detected Text with Bounding Boxes\", fontsize=16)  # Add a title\n",
        "    plt.show()\n",
        "\n",
        "    return all_text_data\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "0-_e2_1lb_xo",
        "outputId": "5b340dac-b495-44fb-e6ed-a8fcf0fc14c9"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "[2024/10/19 07:30:14] ppocr DEBUG: Namespace(help='==SUPPRESS==', use_gpu=False, use_xpu=False, use_npu=False, use_mlu=False, ir_optim=True, use_tensorrt=False, min_subgraph_size=15, precision='fp32', gpu_mem=500, gpu_id=0, image_dir=None, page_num=0, det_algorithm='DB', det_model_dir='/root/.paddleocr/whl/det/en/en_PP-OCRv3_det_infer', det_limit_side_len=960, det_limit_type='max', det_box_type='quad', det_db_thresh=0.3, det_db_box_thresh=0.6, det_db_unclip_ratio=1.5, max_batch_size=10, use_dilation=False, det_db_score_mode='fast', det_east_score_thresh=0.8, det_east_cover_thresh=0.1, det_east_nms_thresh=0.2, det_sast_score_thresh=0.5, det_sast_nms_thresh=0.2, det_pse_thresh=0, det_pse_box_thresh=0.85, det_pse_min_area=16, det_pse_scale=1, scales=[8, 16, 32], alpha=1.0, beta=1.0, fourier_degree=5, rec_algorithm='SVTR_LCNet', rec_model_dir='/root/.paddleocr/whl/rec/en/en_PP-OCRv4_rec_infer', rec_image_inverse=True, rec_image_shape='3, 48, 320', rec_batch_num=6, max_text_length=25, rec_char_dict_path='/usr/local/lib/python3.10/dist-packages/paddleocr/ppocr/utils/en_dict.txt', use_space_char=True, vis_font_path='./doc/fonts/simfang.ttf', drop_score=0.5, e2e_algorithm='PGNet', e2e_model_dir=None, e2e_limit_side_len=768, e2e_limit_type='max', e2e_pgnet_score_thresh=0.5, e2e_char_dict_path='./ppocr/utils/ic15_dict.txt', e2e_pgnet_valid_set='totaltext', e2e_pgnet_mode='fast', use_angle_cls=True, cls_model_dir='/root/.paddleocr/whl/cls/ch_ppocr_mobile_v2.0_cls_infer', cls_image_shape='3, 48, 192', label_list=['0', '180'], cls_batch_num=6, cls_thresh=0.9, enable_mkldnn=False, cpu_threads=10, use_pdserving=False, warmup=False, sr_model_dir=None, sr_image_shape='3, 32, 128', sr_batch_num=1, draw_img_save_dir='./inference_results', save_crop_res=False, crop_res_save_dir='./output', use_mp=False, total_process_num=1, process_id=0, benchmark=False, save_log_path='./log_output/', show_log=True, use_onnx=False, return_word_box=False, output='./output', table_max_len=488, table_algorithm='TableAttn', table_model_dir=None, merge_no_span_structure=True, table_char_dict_path=None, formula_algorithm='LaTeXOCR', formula_model_dir=None, formula_char_dict_path=None, formula_batch_num=1, layout_model_dir=None, layout_dict_path=None, layout_score_threshold=0.5, layout_nms_threshold=0.5, kie_algorithm='LayoutXLM', ser_model_dir=None, re_model_dir=None, use_visual_backbone=True, ser_dict_path='../train_data/XFUND/class_list_xfun.txt', ocr_order_method=None, mode='structure', image_orientation=False, layout=True, table=True, formula=False, ocr=True, recovery=False, recovery_to_markdown=False, use_pdf2docx_api=False, invert=False, binarize=False, alphacolor=(255, 255, 255), lang='en', det=True, rec=True, type='ocr', savefile=False, ocr_version='PP-OCRv4', structure_version='PP-StructureV2')\n"
          ]
        }
      ],
      "source": [
        "# Initialize PaddleOCR\n",
        "ocr = PaddleOCR(use_angle_cls=True, lang='en')\n",
        "\n",
        "def detect_and_ocr(image):\n",
        "    \"\"\"Detect objects using YOLO, draw bounding boxes, and perform OCR.\"\"\"\n",
        "    # Convert input image from PIL to OpenCV format\n",
        "    image = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)\n",
        "\n",
        "    # Run inference using YOLO model\n",
        "    results = model(image)\n",
        "    boxes = results[0].boxes.xyxy.cpu().numpy()  # Extract bounding box coordinates\n",
        "\n",
        "    extracted_texts = []\n",
        "    for (x1, y1, x2, y2) in boxes:\n",
        "        # Draw bounding box on the original image\n",
        "        cv2.rectangle(image, (int(x1), int(y1)), (int(x2), int(y2)), (0, 255, 0), 2)\n",
        "\n",
        "        # Perform OCR on the detected region using the original image and bounding box coordinates\n",
        "        region = image[int(y1):int(y2), int(x1):int(x2)]\n",
        "        ocr_result = ocr.ocr(region, cls=True)\n",
        "\n",
        "        # Check if ocr_result is None or empty\n",
        "        if ocr_result and isinstance(ocr_result, list) and ocr_result[0]:\n",
        "            for idx, line in enumerate(ocr_result[0]):\n",
        "                box = line[0]  # Get the bounding box coordinates\n",
        "                text = line[1][0]  # Extracted text\n",
        "                print(f\"[DEBUG] Box {idx + 1}: {text}\")  # Debug output\n",
        "                extracted_texts.append(text)\n",
        "        else:\n",
        "            # Handle case when OCR returns no result\n",
        "            print(f\"[DEBUG] No OCR result for region: ({x1}, {y1}, {x2}, {y2}) or OCR returned None\")\n",
        "            extracted_texts.append(\"No OCR result found\")  # Append a message to indicate no result\n",
        "\n",
        "    # Convert image to RGB for Gradio display\n",
        "    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n",
        "\n",
        "    # Join all extracted texts into a single string\n",
        "    result_text = \"\\n\".join(str(text) for text in extracted_texts)\n",
        "\n",
        "    # Call the Gemini context correction function\n",
        "    refined_text = gemini_context_correction(result_text)\n",
        "    print(\"[DEBUG] Gemini Refined Text:\\n\", refined_text)\n",
        "\n",
        "    # Validate and correct dates\n",
        "    validated_output = extract_and_validate_with_gemini(refined_text)\n",
        "\n",
        "    print(\"[DEBUG] Validated Output from Gemini:\\n\", validated_output)\n",
        "\n",
        "    # Return image with bounding boxes and results\n",
        "    return image_rgb, result_text, refined_text, validated_output\n",
        "\n",
        "def further_processing(image, previous_result_text):\n",
        "    bounding_boxes_list = new_draw_bounding_boxes(image)\n",
        "    print(\"[DEBUG] \", bounding_boxes_list, type(bounding_boxes_list))\n",
        "    combined_text = previous_result_text\n",
        "    for text in bounding_boxes_list:\n",
        "        combined_text += text\n",
        "        combined_text += \"\\n\"\n",
        "    print(\"[DEBUG] combined text\", combined_text)\n",
        "    # Call Gemini for context correction and refinement\n",
        "    refined_output = gemini_context_correction(combined_text)\n",
        "    print(\"[DEBUG] Gemini Refined Output:\\n\", refined_output)\n",
        "\n",
        "    return refined_output   # Return refined output for display\n",
        "\n",
        "def handle_processing(validated_output):\n",
        "    \"\"\"Decide whether to proceed with further processing.\"\"\"\n",
        "    # Extract the manufacturing and expiration dates from the string\n",
        "    try:\n",
        "        mfg_date_str = validated_output.split(\"Manufacturing Date: \")[1].split(\",\")[0].strip()\n",
        "        exp_date_str = validated_output.split(\"Expiration Date: \")[1].strip()\n",
        "\n",
        "        # Convert the extracted values to integers\n",
        "        mfg_date = int(mfg_date_str)\n",
        "        exp_date = int(exp_date_str)\n",
        "        print(\"Further processing: \", mfg_date, exp_date)\n",
        "\n",
        "    except (IndexError, ValueError) as e:\n",
        "        print(f\"[ERROR] Failed to parse dates: {e}\")\n",
        "        return gr.update(visible=False)  # Hide button on error\n",
        "\n",
        "    # Check if both dates are -1\n",
        "    if mfg_date == -1 and exp_date == -1:\n",
        "        print(\"[DEBUG] Showing the 'Further Processing' button.\")  # Debug print\n",
        "        return gr.update(visible=True)  # Show 'Further Processing' button\n",
        "    print(\"[DEBUG] Hiding the 'Further Processing' button.\")  # Debug print\n",
        "    return gr.update(visible=False)  # Hide button if dates are valid\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "orkKyX8RYd_o"
      },
      "source": [
        "# Freshness Backend"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "736yg21QEml0",
        "outputId": "881a205a-4423-43e2-f464-9e03f5d7cc6c"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "device(type='cpu')"
            ]
          },
          "execution_count": 209,
          "metadata": {},
          "output_type": "execute_result"
        }
      ],
      "source": [
        "import torch\n",
        "device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n",
        "device"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "KC0ZRdGgEml1"
      },
      "outputs": [],
      "source": [
        "import torch\n",
        "import torch.nn as nn\n",
        "from torchvision import models\n",
        "\n",
        "class EfficientNet_FeatureExtractor(nn.Module):\n",
        "\n",
        "    def __init__(self):\n",
        "        super(EfficientNet_FeatureExtractor, self).__init__()\n",
        "        self.efficientnet = models.efficientnet_b0(pretrained=True)\n",
        "        self.efficientnet = nn.Sequential(*list(self.efficientnet.children())[:-1])\n",
        "\n",
        "    def forward(self, x):\n",
        "        x = self.efficientnet(x)\n",
        "        x = x.view(x.size(0), -1)\n",
        "\n",
        "        return x"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "RmVT5G9tEml2",
        "outputId": "84e0dbb1-7b8c-40bb-cb71-7834b789a12f"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Mean: tensor([0.7245, 0.6862, 0.6531])\n",
            "Std: tensor([0.3061, 0.3356, 0.3472])\n"
          ]
        }
      ],
      "source": [
        "# Calculating the mean and variance of the images whose features will be extracted\n",
        "\n",
        "from torchvision import datasets, transforms\n",
        "from torch.utils.data import DataLoader\n",
        "import numpy as np\n",
        "\n",
        "transform = transforms.Compose([\n",
        "    transforms.Resize(256),\n",
        "    transforms.CenterCrop(224),\n",
        "    transforms.ToTensor(),\n",
        "])\n",
        "\n",
        "dataset = datasets.ImageFolder(root='/content/drive/MyDrive/Bananas/Dataset', transform=transform)\n",
        "\n",
        "# Create a DataLoader\n",
        "loader = DataLoader(dataset, batch_size=32, shuffle=False)\n",
        "\n",
        "# Initialize variables to calculate the mean and std\n",
        "mean = 0.0\n",
        "std = 0.0\n",
        "total_images = 0\n",
        "\n",
        "# Iterate over the dataset to compute mean and std\n",
        "for images, _ in loader:\n",
        "    batch_samples = images.size(0)\n",
        "    images = images.view(batch_samples, images.size(1), -1)  # Flatten each image (C, H*W)\n",
        "\n",
        "    # Calculate mean and std for this batch and add to the running total\n",
        "    mean += images.mean(2).sum(0)\n",
        "    std += images.std(2).sum(0)\n",
        "    total_images += batch_samples\n",
        "\n",
        "# Final mean and std across all images in the dataset\n",
        "mean /= total_images\n",
        "std /= total_images\n",
        "\n",
        "print(f\"Mean: {mean}\")\n",
        "print(f\"Std: {std}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "lJaCskJVEml2"
      },
      "outputs": [],
      "source": [
        "\n",
        "# Transforming the images into the format so that they can be passes through the EfficientNet model\n",
        "# Define the transform for your dataset, including normalization with custom mean and std\n",
        "transform = transforms.Compose([\n",
        "    transforms.Resize(256),\n",
        "    transforms.CenterCrop(224),\n",
        "    transforms.ToTensor(),\n",
        "    transforms.Normalize(mean=mean, std=std)\n",
        "])\n",
        "\n",
        "test_dataset = datasets.ImageFolder(root='/content/drive/MyDrive/Bananas/Dataset', transform=transform)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "CLK5k4uPEml3",
        "outputId": "494553b2-49ab-4a25-af6c-7b0c0d93203e"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Shape of batch 0: (50, 1280)\n",
            "Shape of batch 1: (50, 1280)\n"
          ]
        }
      ],
      "source": [
        "# Extracting features from Efficientnet model\n",
        "def extract_features(test_dataset):\n",
        "\n",
        "  # Initialize the feature extractor model\n",
        "  model = EfficientNet_FeatureExtractor().to(device)\n",
        "  model.eval()  # Set to evaluation mode\n",
        "\n",
        "  # Create a DataLoader for the test dataset\n",
        "  test_loader = DataLoader(test_dataset, batch_size=50, shuffle=False)\n",
        "\n",
        "\n",
        "  # Store the extracted features\n",
        "  all_features = []\n",
        "\n",
        "  # Loop over the test dataset and extract features\n",
        "  with torch.no_grad():  # Disable gradient calculation for efficiency\n",
        "      for images, _ in test_loader:\n",
        "          # Send the images to the same device as the model\n",
        "          images = images.to(device)\n",
        "\n",
        "          # Pass the images through the feature extractor\n",
        "          features = model(images)\n",
        "\n",
        "          # Move features to CPU and convert to NumPy (optional)\n",
        "          features = features.cpu().numpy()\n",
        "\n",
        "          # Append the features for further use\n",
        "          all_features.append(features)\n",
        "  return all_features\n",
        "\n",
        "all_features = extract_features(test_dataset)\n",
        "\n",
        "# Print the shape of each batch stored in the list\n",
        "for i, features in enumerate(all_features):\n",
        "    print(f\"Shape of batch {i}: {features.shape}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "tIOaksa3Eml4",
        "outputId": "7b450847-c816-4031-a1f5-ac02c0a45856"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Feature Mean Shape: torch.Size([1280])\n"
          ]
        }
      ],
      "source": [
        "# Calculating the mean and varinance of the entire distribution\n",
        "\n",
        "# Stack all the feature vectors into a single tensor\n",
        "all_features_tensor = torch.cat([torch.tensor(batch) for batch in all_features], dim=0)\n",
        "\n",
        "# Calculate the mean and variance along the feature dimension\n",
        "feature_mean = all_features_tensor.mean(dim=0)\n",
        "feature_mean = feature_mean.to(device)\n",
        "feature_variance = all_features_tensor.var(dim=0)\n",
        "\n",
        "print(f\"Feature Mean Shape: {feature_mean.shape}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "nh_qRxLPEml4",
        "outputId": "18c105dc-ba59-4a3a-ca5e-8d7d5d889546"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "All Feature Tensor Shape: torch.Size([100, 1280])\n",
            "Covariance Matrix Shape: torch.Size([1280, 1280])\n"
          ]
        }
      ],
      "source": [
        "all_features_tensor = torch.cat([torch.tensor(f) for f in all_features], dim=0)\n",
        "all_features_tensor = all_features_tensor.to(device)\n",
        "feature_mean_temp = all_features_tensor.mean(dim=0)\n",
        "centered_features = all_features_tensor - feature_mean_temp\n",
        "\n",
        "# Calculate the covariance matrix\n",
        "# Covariance matrix: (num_features, num_features)\n",
        "covariance_matrix = torch.cov(centered_features.T)\n",
        "covariance_matrix = covariance_matrix.to(device)\n",
        "\n",
        "print(f\"All Feature Tensor Shape: {all_features_tensor.shape}\")\n",
        "print(f\"Covariance Matrix Shape: {covariance_matrix.shape}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "gZ8w2DKtEml4"
      },
      "outputs": [],
      "source": [
        "# Defining the function to calculate the Mahalanobis distance\n",
        "\n",
        "import torch\n",
        "\n",
        "def mahalanobis(x=None, feature_mean=None, feature_cov=None):\n",
        "    \"\"\"Compute the Mahalanobis Distance between each row of x and the data\n",
        "    x             : tensor of shape [batch_size, num_features], feature vectors of test data\n",
        "    feature_mean  : tensor of shape [num_features], mean of the training feature vectors\n",
        "    feature_cov   : tensor of shape [num_features, num_features], covariance matrix of the training feature vectors\n",
        "    \"\"\"\n",
        "\n",
        "    # Subtract the mean from x\n",
        "    x_minus_mu = x - feature_mean\n",
        "\n",
        "    # Invert the covariance matrix\n",
        "    inv_covmat = torch.inverse(feature_cov)\n",
        "\n",
        "    # Mahalanobis distance computation: (x - mu)^T * inv_cov * (x - mu)\n",
        "    left_term = torch.matmul(x_minus_mu, inv_covmat)\n",
        "    mahal = torch.matmul(left_term, x_minus_mu.T)\n",
        "    return mahal.diag()\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "_LOAgJifEml4"
      },
      "outputs": [],
      "source": [
        "\n",
        "from PIL import Image\n",
        "from torchvision import transforms\n",
        "\n",
        "transform = transforms.Compose([\n",
        "    transforms.Resize(256),\n",
        "    transforms.CenterCrop(224),\n",
        "    transforms.ToTensor(),\n",
        "    transforms.Normalize(mean=mean, std=std)\n",
        "])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "EvoIDoyVEml5"
      },
      "outputs": [],
      "source": [
        "def classify_banana_by_distance(distance):\n",
        "    \"\"\"\n",
        "    Classifies the banana's freshness based on the Mahalanobis distance.\n",
        "\n",
        "    Args:\n",
        "        distance (float): Mahalanobis distance of the banana.\n",
        "\n",
        "    Returns:\n",
        "        dict: A dictionary containing the classification and relevant details.\n",
        "    \"\"\"\n",
        "\n",
        "    # Define thresholds for classification based on the provided distances\n",
        "    if distance >= 9:\n",
        "        # Case 1: Completely Fresh Banana\n",
        "        return {\n",
        "            \"Classification\": \"Completely Fresh\",\n",
        "            \"Freshness Index\": 10,\n",
        "            \"Color\": \"Mostly yellow, little to no brown spots\",\n",
        "            \"Dark Spots\": \"0-10%\",\n",
        "            \"Shelf Life\": \"5-7 days\",\n",
        "            \"Ripeness Stage\": \"Just ripe\",\n",
        "            \"Texture\": \"Firm and smooth\"\n",
        "        }\n",
        "    elif -90 <= distance < 0:\n",
        "        # Case 2: Banana with 40% Dark Brown Spots\n",
        "        return {\n",
        "            \"Classification\": \"Moderately Ripe\",\n",
        "            \"Freshness Index\": 6,\n",
        "            \"Color\": \"60% yellow, 40% dark spots\",\n",
        "            \"Dark Spots\": \"40% dark spots\",\n",
        "            \"Shelf Life\": \"2-3 days\",\n",
        "            \"Ripeness Stage\": \"Moderately ripe\",\n",
        "            \"Texture\": \"Some softness, still edible\"\n",
        "        }\n",
        "    else:\n",
        "        # Case 3: Almost Rotten Banana\n",
        "        return {\n",
        "            \"Classification\": \"Almost Rotten\",\n",
        "            \"Freshness Index\": 2,\n",
        "            \"Color\": \"Mostly brown or black, very few yellow patches\",\n",
        "            \"Dark Spots\": \"80-100% dark spots\",\n",
        "            \"Shelf Life\": \"0-1 days\",\n",
        "            \"Ripeness Stage\": \"Overripe\",\n",
        "            \"Texture\": \"Very soft, mushy, may leak moisture\"\n",
        "        }\n",
        "\n",
        "    return result\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "g6BDk8fhHp2R"
      },
      "outputs": [],
      "source": [
        "def classify_banana(image):\n",
        "\n",
        "    model = EfficientNet_FeatureExtractor().to(device)\n",
        "    model.eval()  # Set to evaluation mode\n",
        "\n",
        "    # Load and transform the image\n",
        "    img = Image.fromarray(image)\n",
        "    img_transformed = transform(img).unsqueeze(0).to(device)\n",
        "\n",
        "    # Feature extraction\n",
        "    with torch.no_grad():\n",
        "        features = model(img_transformed)\n",
        "\n",
        "    # Calculate Mahalanobis distance\n",
        "    distance = mahalanobis(features, feature_mean, covariance_matrix)\n",
        "    distance = (distance) / 1e8\n",
        "\n",
        "    return classify_banana_by_distance(distance)\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "W8BOmfnwKpyM"
      },
      "source": [
        "## Freshness Detect Using image"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "Au3r6dW6KpLq"
      },
      "outputs": [],
      "source": [
        "def detect_objects(image):\n",
        "\n",
        "\n",
        "    # Load the YOLO model\n",
        "    model = YOLO('/kaggle/working/runs/detect/train10/weights/best.pt')\n",
        "    # Run inference on the image\n",
        "    result = model(image)\n",
        "\n",
        "    # Get the image from the result\n",
        "    img = result[0].orig_img  # Original image\n",
        "\n",
        "    # If bounding boxes are detected, loop over them and draw them\n",
        "    if result[0].boxes is not None:\n",
        "        for i, box in enumerate(result[0].boxes.xyxy):  # Bounding boxes (x1, y1, x2, y2)\n",
        "            x1, y1, x2, y2 = map(int, box[:4])\n",
        "            conf = result[0].boxes.conf[i].item()  # Confidence score\n",
        "            cls = int(result[0].boxes.cls[i].item())  # Class ID\n",
        "\n",
        "            # Get the label name\n",
        "            label = f'{result[0].names[cls]} {conf:.2f}'\n",
        "\n",
        "            # Draw the bounding box\n",
        "            cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)  # Green box\n",
        "            cv2.putText(img, label, (x1, y1 + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)\n",
        "\n",
        "    # Convert image to RGB for displaying in Gradio\n",
        "    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n",
        "\n",
        "    return img_rgb"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "SIyxllUHKvB8"
      },
      "source": [
        "## Freshness Detect using Video"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "XB6mvRg0KyPJ"
      },
      "outputs": [],
      "source": [
        "\n",
        "\n",
        "def detect_objects_video(video_file):\n",
        "\n",
        "    # Load the YOLO model\n",
        "    model = YOLO('/kaggle/working/runs/detect/train10/weights/best.pt')\n",
        "    # Open the video file\n",
        "    cap = cv2.VideoCapture(video_file.name)\n",
        "\n",
        "    # Get video properties\n",
        "    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n",
        "    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n",
        "    fps = int(cap.get(cv2.CAP_PROP_FPS))\n",
        "\n",
        "    # Output video writer to save the results\n",
        "    output_video_path = '/kaggle/working/output_detected_video.mp4'\n",
        "    fourcc = cv2.VideoWriter_fourcc(*'mp4v')\n",
        "    out = cv2.VideoWriter(output_video_path, fourcc, fps, (width, height))\n",
        "\n",
        "    # Process each frame from the video\n",
        "    while cap.isOpened():\n",
        "        ret, frame = cap.read()\n",
        "        if not ret:\n",
        "            break  # Exit if there are no more frames\n",
        "\n",
        "        # Run object detection on the frame\n",
        "        results = model(frame)\n",
        "\n",
        "        # Loop over detection results and draw bounding boxes with labels\n",
        "        if results[0].boxes is not None:\n",
        "            for i, box in enumerate(results[0].boxes.xyxy):  # Bounding boxes (x1, y1, x2, y2)\n",
        "                x1, y1, x2, y2 = map(int, box[:4])\n",
        "                conf = results[0].boxes.conf[i].item()  # Confidence score\n",
        "                cls = int(results[0].boxes.cls[i].item())  # Class ID\n",
        "                label = f'{results[0].names[cls]} {conf:.2f}'\n",
        "\n",
        "                # Draw bounding box and label\n",
        "                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)\n",
        "                cv2.putText(frame, label, (x1, y1 + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)\n",
        "\n",
        "        # Write the processed frame to the output video\n",
        "        out.write(frame)\n",
        "\n",
        "    # Release resources\n",
        "    cap.release()\n",
        "    out.release()\n",
        "\n",
        "    return output_video_path"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "DV0ogUeegaAb"
      },
      "source": [
        "# 5. Frontend Of Brand Recognition"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "BhTIOB_vSsbV"
      },
      "source": [
        "## Layout for Image interface"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "vJdfukblgbIf"
      },
      "outputs": [],
      "source": [
        "def create_image_interface():\n",
        "    return gr.Interface(\n",
        "        fn=detect_grocery_items,\n",
        "        inputs=gr.Image(label=\"Upload Image\", height=400, width=400),\n",
        "        outputs=[\n",
        "            gr.Image(label=\"Image with Bounding Boxes\", height=400, width=400),\n",
        "            gr.Dataframe(headers=[\"Item\", \"Quantity\", \"Avg Confidence\"], label=\"Detected Items and Quantities\", elem_id=\"summary_table\"),\n",
        "            gr.Textbox(label=\"Status\", elem_id=\"status_message\")\n",
        "        ],\n",
        "        title=\"Grocery Item Detection in an Image\",\n",
        "        description=\"Upload an image for object detection. The model will return an annotated image, item quantities, and average confidence scores.\",\n",
        "        css=\".gr-table { font-size: 16px; text-align: left; width: 50%; margin: auto; } #summary_table { margin-top: 20px; }\"\n",
        "    )"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "ifKhlFkZgie2"
      },
      "source": [
        "## Layout For Video Interface"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "aH4yO7kygkp3"
      },
      "outputs": [],
      "source": [
        "def create_video_interface():\n",
        "    return gr.Interface(\n",
        "        fn=annotate_video,  # This is the function that processes the video and returns the results\n",
        "        inputs=gr.Video(label=\"Upload Video\", height=400, width=400),\n",
        "        outputs=[\n",
        "            gr.Video(label=\"Annotated Video\", height=400, width=400),  # To display the annotated video\n",
        "            gr.Dataframe(headers=[\"Item\", \"Quantity\"], label=\"Detected Items and Quantities\", elem_id=\"summary_table\"),\n",
        "            gr.Textbox(label=\"Status\", elem_id=\"status_message\")  # Any additional status messages\n",
        "        ],\n",
        "        title=\"Grocery Item Detection in a Video\",\n",
        "        description=\"Upload a video for object detection. The model will return an annotated video with bounding boxes and item quantities. Low confidence values may indicate incorrect detection.\",\n",
        "        css=\"\"\"\n",
        "            .gr-table { font-size: 16px; text-align: left; width: 50%; margin: auto; }\n",
        "            #summary_table { margin-top: 20px; }\n",
        "        \"\"\"\n",
        "    )"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "1vmcJbgmrYl8"
      },
      "outputs": [],
      "source": [
        "def create_brand_recog_interface():\n",
        "    with gr.Blocks() as demo:\n",
        "        gr.Markdown(\"# Flipkart Grid Robotics Track - Brand Recognition Interface\")\n",
        "\n",
        "        with gr.Tabs():\n",
        "            with gr.Tab(\"Image\"):\n",
        "                create_image_interface()\n",
        "            with gr.Tab(\"Video\"):\n",
        "                create_video_interface()\n",
        "    return demo\n",
        "\n",
        "Brand_recog = create_brand_recog_interface()\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 21,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 1000
        },
        "id": "JOgfVjWrsigx",
        "outputId": "590e86b4-3802-4a27-a35d-054709edbd43"
      },
      "outputs": [
        {
          "metadata": {
            "tags": null
          },
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Colab notebook detected. This cell will run indefinitely so that you can see errors and logs. To turn off, set debug=False in launch().\n",
            "* Running on public URL: https://69c2960500e0c4f410.gradio.live\n",
            "\n",
            "This share link expires in 72 hours. For free permanent hosting and GPU upgrades, run `gradio deploy` from the terminal in the working directory to deploy to Hugging Face Spaces (https://huggingface.co/spaces)\n"
          ]
        },
        {
          "data": {
            "text/html": [
              "<div><iframe src=\"https://69c2960500e0c4f410.gradio.live\" width=\"100%\" height=\"500\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>"
            ],
            "text/plain": [
              "<IPython.core.display.HTML object>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        },
        {
          "metadata": {
            "tags": null
          },
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "\n",
            "0: 416x640 1 Tide, 363.5ms\n",
            "Speed: 24.2ms preprocess, 363.5ms inference, 1.0ms postprocess per image at shape (1, 3, 416, 640)\n"
          ]
        },
        {
          "metadata": {
            "tags": null
          },
          "name": "stderr",
          "output_type": "stream",
          "text": [
            "Traceback (most recent call last):\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/queueing.py\", line 622, in process_events\n",
            "    response = await route_utils.call_process_api(\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/route_utils.py\", line 323, in call_process_api\n",
            "    output = await app.get_blocks().process_api(\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/blocks.py\", line 2014, in process_api\n",
            "    result = await self.call_function(\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/blocks.py\", line 1567, in call_function\n",
            "    prediction = await anyio.to_thread.run_sync(  # type: ignore\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/anyio/to_thread.py\", line 33, in run_sync\n",
            "    return await get_asynclib().run_sync_in_worker_thread(\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/anyio/_backends/_asyncio.py\", line 877, in run_sync_in_worker_thread\n",
            "    return await future\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/anyio/_backends/_asyncio.py\", line 807, in run\n",
            "    result = context.run(func, *args)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/utils.py\", line 846, in wrapper\n",
            "    response = f(*args, **kwargs)\n",
            "  File \"<ipython-input-17-4868f93430d6>\", line 3, in annotate_video\n",
            "    confirmed_items = process_video(input_video, output_path)\n",
            "  File \"<ipython-input-16-8e04333a2670>\", line 2, in process_video\n",
            "    model = YOLO('kitkat_n.pt')\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/models/yolo/model.py\", line 23, in __init__\n",
            "    super().__init__(model=model, task=task, verbose=verbose)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/engine/model.py\", line 145, in __init__\n",
            "    self._load(model, task=task)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/engine/model.py\", line 285, in _load\n",
            "    self.model, self.ckpt = attempt_load_one_weight(weights)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/nn/tasks.py\", line 910, in attempt_load_one_weight\n",
            "    ckpt, weight = torch_safe_load(weight)  # load ckpt\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/nn/tasks.py\", line 837, in torch_safe_load\n",
            "    ckpt = torch.load(file, map_location=\"cpu\")\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/utils/patches.py\", line 86, in torch_load\n",
            "    return _torch_load(*args, **kwargs)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/torch/serialization.py\", line 1065, in load\n",
            "    with _open_file_like(f, 'rb') as opened_file:\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/torch/serialization.py\", line 468, in _open_file_like\n",
            "    return _open_file(name_or_buffer, mode)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/torch/serialization.py\", line 449, in __init__\n",
            "    super().__init__(open(name, mode))\n",
            "FileNotFoundError: [Errno 2] No such file or directory: 'kitkat_n.pt'\n",
            "Traceback (most recent call last):\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/queueing.py\", line 622, in process_events\n",
            "    response = await route_utils.call_process_api(\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/route_utils.py\", line 323, in call_process_api\n",
            "    output = await app.get_blocks().process_api(\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/blocks.py\", line 2014, in process_api\n",
            "    result = await self.call_function(\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/blocks.py\", line 1567, in call_function\n",
            "    prediction = await anyio.to_thread.run_sync(  # type: ignore\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/anyio/to_thread.py\", line 33, in run_sync\n",
            "    return await get_asynclib().run_sync_in_worker_thread(\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/anyio/_backends/_asyncio.py\", line 877, in run_sync_in_worker_thread\n",
            "    return await future\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/anyio/_backends/_asyncio.py\", line 807, in run\n",
            "    result = context.run(func, *args)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/gradio/utils.py\", line 846, in wrapper\n",
            "    response = f(*args, **kwargs)\n",
            "  File \"<ipython-input-17-4868f93430d6>\", line 3, in annotate_video\n",
            "    confirmed_items = process_video(input_video, output_path)\n",
            "  File \"<ipython-input-16-8e04333a2670>\", line 2, in process_video\n",
            "    model = YOLO('kitkat_n.pt')\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/models/yolo/model.py\", line 23, in __init__\n",
            "    super().__init__(model=model, task=task, verbose=verbose)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/engine/model.py\", line 145, in __init__\n",
            "    self._load(model, task=task)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/engine/model.py\", line 285, in _load\n",
            "    self.model, self.ckpt = attempt_load_one_weight(weights)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/nn/tasks.py\", line 910, in attempt_load_one_weight\n",
            "    ckpt, weight = torch_safe_load(weight)  # load ckpt\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/nn/tasks.py\", line 837, in torch_safe_load\n",
            "    ckpt = torch.load(file, map_location=\"cpu\")\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/ultralytics/utils/patches.py\", line 86, in torch_load\n",
            "    return _torch_load(*args, **kwargs)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/torch/serialization.py\", line 1065, in load\n",
            "    with _open_file_like(f, 'rb') as opened_file:\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/torch/serialization.py\", line 468, in _open_file_like\n",
            "    return _open_file(name_or_buffer, mode)\n",
            "  File \"/usr/local/lib/python3.10/dist-packages/torch/serialization.py\", line 449, in __init__\n",
            "    super().__init__(open(name, mode))\n",
            "FileNotFoundError: [Errno 2] No such file or directory: 'kitkat_n.pt'\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Keyboard interruption in main thread... closing server.\n",
            "Killing tunnel 127.0.0.1:7860 <> https://69c2960500e0c4f410.gradio.live\n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": []
          },
          "metadata": {},
          "execution_count": 21
        }
      ],
      "source": [
        "Brand_recog.launch(share=True, debug=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "zNX7ER48owjm"
      },
      "source": [
        "# Frontend Of OCR"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "0HXJEYyyowjm"
      },
      "outputs": [],
      "source": [
        "def create_ocr_interface():\n",
        "    with gr.Blocks() as ocr_interface:\n",
        "        gr.Markdown(\"# Flipkart Grid Robotics Track - OCR Interface\")\n",
        "\n",
        "        with gr.Tabs():\n",
        "            with gr.TabItem(\"Upload & Detection\"):\n",
        "                with gr.Row():\n",
        "                    # Input: Upload image\n",
        "                    input_image = gr.Image(type=\"pil\", label=\"Upload Image\", height=400, width=400)\n",
        "                    output_image = gr.Image(label=\"Image with Bounding Boxes\", height=400, width=400)\n",
        "\n",
        "                # Button for Analyze Image & Extract Text\n",
        "                btn = gr.Button(\"Analyze Image & Extract Text\")\n",
        "\n",
        "            with gr.TabItem(\"OCR Results\"):\n",
        "                with gr.Row():\n",
        "                    extracted_textbox = gr.Textbox(label=\"Extracted OCR Text\", lines=5)\n",
        "                with gr.Row():\n",
        "                    refined_textbox = gr.Textbox(label=\"Refined Text from Gemini\", lines=5)\n",
        "                with gr.Row():\n",
        "                    validated_textbox = gr.Textbox(label=\"Validated Output\", lines=5)\n",
        "\n",
        "                # Comprehensive OCR button (Initially hidden)\n",
        "                further_button = gr.Button(\"Comprehensive OCR\", visible=False)\n",
        "\n",
        "        # Detect and OCR button click event\n",
        "        btn.click(\n",
        "            detect_and_ocr,\n",
        "            inputs=[input_image],\n",
        "            outputs=[output_image, extracted_textbox, refined_textbox, validated_textbox]\n",
        "        )\n",
        "\n",
        "        # Further processing button click event\n",
        "        further_button.click(\n",
        "            further_processing,\n",
        "            inputs=[input_image, extracted_textbox],\n",
        "            outputs=refined_textbox\n",
        "        )\n",
        "\n",
        "        # Monitor validated output to control button visibility\n",
        "        refined_textbox.change(\n",
        "            handle_processing,\n",
        "            inputs=[validated_textbox],\n",
        "            outputs=[further_button]\n",
        "        )\n",
        "\n",
        "        # Hide the validated_textbox when \"Comprehensive OCR\" is clicked\n",
        "        further_button.click(\n",
        "            lambda: gr.update(visible=False),\n",
        "            outputs=[validated_textbox]\n",
        "        )\n",
        "\n",
        "    return ocr_interface\n",
        "\n",
        "# Create and launch the OCR interface\n",
        "ocr_interface = create_ocr_interface()\n",
        "# ocr_interface.launch(share=True, debug=True)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 1000
        },
        "id": "nT3NRcS7r30S",
        "outputId": "53caaec8-b8df-41b0-8d94-cd0a322ad7b1"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Colab notebook detected. This cell will run indefinitely so that you can see errors and logs. To turn off, set debug=False in launch().\n",
            "* Running on public URL: https://638e20f62ad036d249.gradio.live\n",
            "\n",
            "This share link expires in 72 hours. For free permanent hosting and GPU upgrades, run `gradio deploy` from the terminal in the working directory to deploy to Hugging Face Spaces (https://huggingface.co/spaces)\n"
          ]
        },
        {
          "data": {
            "text/html": [
              "<div><iframe src=\"https://638e20f62ad036d249.gradio.live\" width=\"100%\" height=\"500\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>"
            ],
            "text/plain": [
              "<IPython.core.display.HTML object>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        },
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "\n",
            "0: 768x128 2 Labels, 1685.0ms\n",
            "Speed: 23.8ms preprocess, 1685.0ms inference, 31.4ms postprocess per image at shape (1, 3, 768, 128)\n",
            "[2024/10/19 07:31:14] ppocr DEBUG: dt_boxes num : 5, elapsed : 0.13268327713012695\n",
            "[2024/10/19 07:31:14] ppocr DEBUG: cls num  : 5, elapsed : 0.05085182189941406\n",
            "[2024/10/19 07:31:14] ppocr DEBUG: rec_res num  : 5, elapsed : 0.33078527450561523\n",
            "[DEBUG] Box 1: R5.169/-\n",
            "[DEBUG] Box 2: Rs.4.83Per\n",
            "[DEBUG] Box 3: 8300185\n",
            "[DEBUG] Box 4: 01/2023\n",
            "[DEBUG] Box 5: 12/2025\n",
            "[2024/10/19 07:31:14] ppocr DEBUG: dt_boxes num : 10, elapsed : 0.1305692195892334\n",
            "[2024/10/19 07:31:14] ppocr DEBUG: cls num  : 10, elapsed : 0.11341714859008789\n",
            "[2024/10/19 07:31:17] ppocr DEBUG: rec_res num  : 10, elapsed : 2.4053597450256348\n",
            "[DEBUG] Box 1: MRP\n",
            "[DEBUG] Box 2: R5.169/-\n",
            "[DEBUG] Box 3: (ep\n",
            "[DEBUG] Box 4: Rs.4.83Per\n",
            "[DEBUG] Box 5: Batch No.:\n",
            "[DEBUG] Box 6: 830085\n",
            "[DEBUG] Box 7: 01/2023\n",
            "[DEBUG] Box 8: Mfg.Date:\n",
            "[DEBUG] Box 9: 12/2025\n",
            "[DEBUG] Box 10: Exp.Date:\n",
            "[DEBUG] Gemini Refined Text:\n",
            " Manufacturing Date: 01/2023\n",
            "Expiration Date: 12/2025\n",
            "MRP: R5.169/- \n",
            "\n",
            "[DEBUG] Gemini Response: Manufacturing Date: 01/01/2023, Expiration Date: 12/01/2025\n",
            "[DEBUG] Validated Output from Gemini:\n",
            " Manufacturing Date: 01/01/2023, Expiration Date: 12/01/2025\n",
            "[ERROR] Failed to parse dates: invalid literal for int() with base 10: '01/01/2023'\n",
            "Keyboard interruption in main thread... closing server.\n",
            "Killing tunnel 127.0.0.1:7860 <> https://638e20f62ad036d249.gradio.live\n"
          ]
        },
        {
          "data": {
            "text/plain": []
          },
          "execution_count": 12,
          "metadata": {},
          "output_type": "execute_result"
        }
      ],
      "source": [
        "ocr_interface.launch(share=True, debug=True)\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "yX_xuglgZb53"
      },
      "source": [
        "# Frontend for Fruit Freshness"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "5a0CKwOyaEim"
      },
      "source": [
        "## Layout for Freshness Index"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "8mAs2FhfZhDS"
      },
      "outputs": [],
      "source": [
        "def create_banana_classifier_interface():\n",
        "    return gr.Interface(\n",
        "        fn=classify_banana,  # Your classification function\n",
        "        inputs=gr.Image(type=\"numpy\", label=\"Upload a Banana Image\"),  # Removed tool argument\n",
        "        outputs=gr.JSON(label=\"Classification Result\"),\n",
        "        title=\"Banana Freshness Classifier\",\n",
        "        description=\"Upload an image of a banana to classify its freshness.\",\n",
        "        css=\"#component-0 { width: 300px; height: 300px; }\"  # Keep your CSS for fixed size\n",
        "    )"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "xGR_1z3tjf2O"
      },
      "outputs": [],
      "source": [
        "def image_freshness_interface():\n",
        "    return gr.Interface(\n",
        "        fn=detect_objects,  # Your detection function\n",
        "        inputs=gr.Image(type=\"numpy\", label=\"Upload an Image\"),  # Removed tool argument\n",
        "        outputs=gr.Image(type=\"numpy\", label=\"Detected Image\"),\n",
        "        live=True,\n",
        "        title=\"Image Freshness Detection\",\n",
        "        description=\"Upload an image of fruit to detect freshness.\",\n",
        "        css=\"#component-0 { width: 300px; height: 300px; }\"  # Keep your CSS for fixed size\n",
        "    )\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "QpIgYpExkDTw"
      },
      "outputs": [],
      "source": [
        "def video_freshness_interface():\n",
        "    return gr.Interface(\n",
        "        fn=process_video,  # Your video processing function\n",
        "        inputs=gr.Video(label=\"Upload a Video\"),\n",
        "        outputs=gr.Video(label=\"Processed Video\"),\n",
        "        title=\"Video Freshness Detection\",\n",
        "        description=\"Upload a video of fruit to detect freshness.\",\n",
        "        css=\"#component-0 { width: 300px; height: 300px; }\"  # Keep your CSS for fixed size\n",
        "    )\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "aTp0lEfmkaOV",
        "outputId": "cc13e100-313a-4805-9ecb-ea32eba520dc"
      },
      "outputs": [
        {
          "name": "stderr",
          "output_type": "stream",
          "text": [
            "/usr/local/lib/python3.10/dist-packages/gradio/utils.py:980: UserWarning: Expected 2 arguments for function <function process_video at 0x7fbf99880160>, received 1.\n",
            "  warnings.warn(\n",
            "/usr/local/lib/python3.10/dist-packages/gradio/utils.py:984: UserWarning: Expected at least 2 arguments for function <function process_video at 0x7fbf99880160>, received 1.\n",
            "  warnings.warn(\n"
          ]
        }
      ],
      "source": [
        "def create_fruit_interface():\n",
        "    with gr.Blocks() as demo:\n",
        "        gr.Markdown(\"# Flipkart Grid Robotics Track - Fruits Interface\")\n",
        "        with gr.Tabs():\n",
        "            with gr.Tab(\"Banana\"):\n",
        "                create_banana_classifier_interface()  # Call the banana classifier interface\n",
        "            with gr.Tab(\"Image Freshness\"):\n",
        "                image_freshness_interface()  # Call the image freshness interface\n",
        "            with gr.Tab(\"Video Freshness\"):\n",
        "                video_freshness_interface()  # Call the video freshness interface\n",
        "    return demo\n",
        "\n",
        "\n",
        "Fruit = create_fruit_interface()\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "J8OSFWUxgpkK"
      },
      "source": [
        "# 6. Create a Tabbed Interface for Both Image and Video\n",
        "### Here, we combine the image and video interfaces into a tabbed structure so users can switch between them easily."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "uU5PErJWgx2A"
      },
      "outputs": [],
      "source": [
        "def create_tabbed_interface():\n",
        "    return gr.TabbedInterface(\n",
        "        [Brand_recog,  ocr_interface,Fruit ],\n",
        "        [\"Brand Recongnition\", \"OCR\" , \"Fruit Freshness\"]\n",
        "    )\n",
        "\n",
        "tabbed_interface = create_tabbed_interface()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "iZoOhTz_fuhC"
      },
      "source": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "PXib0pFpg5U9"
      },
      "source": [
        "# 7. Launch the Gradio Interface\n",
        "### Finally, launch the Gradio interface to make it interactable."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 648
        },
        "id": "A4GOdtXag7uc",
        "outputId": "9d0edca7-8487-4c97-f496-0cda32aa7162"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Running Gradio in a Colab notebook requires sharing enabled. Automatically setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).\n",
            "\n",
            "Colab notebook detected. To show errors in colab notebook, set debug=True in launch()\n",
            "* Running on public URL: https://12e120157408d76c3f.gradio.live\n",
            "\n",
            "This share link expires in 72 hours. For free permanent hosting and GPU upgrades, run `gradio deploy` from the terminal in the working directory to deploy to Hugging Face Spaces (https://huggingface.co/spaces)\n"
          ]
        },
        {
          "data": {
            "text/html": [
              "<div><iframe src=\"https://12e120157408d76c3f.gradio.live\" width=\"100%\" height=\"500\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>"
            ],
            "text/plain": [
              "<IPython.core.display.HTML object>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        },
        {
          "data": {
            "text/plain": []
          },
          "execution_count": 231,
          "metadata": {},
          "output_type": "execute_result"
        }
      ],
      "source": [
        "tabbed_interface.launch()"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "collapsed_sections": [
        "PFop7A1Vfvjm",
        "SRN1sfE1f83w",
        "VBUU8AruRPZh",
        "qiZYtWJSgHK2",
        "6Oa81GnqbSFu",
        "TRPUy-YGb7OO",
        "orkKyX8RYd_o",
        "DV0ogUeegaAb",
        "zNX7ER48owjm",
        "yX_xuglgZb53",
        "J8OSFWUxgpkK",
        "PXib0pFpg5U9"
      ],
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}